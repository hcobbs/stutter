# Red Team Security Report: Stutter CSPRNG

**Date:** 2025-12-24
**Target:** `stutter` library source code
**Analyst:** Gemini

## Executive Summary

The `stutter` library is a custom Cryptographically Secure Pseudorandom Number Generator (CSPRNG). The codebase demonstrates a high level of discipline in general C programming practices, including modern compiler hardening, strict standards compliance, and avoidance of common buffer overflow and format string vulnerabilities.

However, the security of the entire library is critically undermined by its core design choice: the use of custom, in-house implementations of the SHA-256 and AES-256 cryptographic primitives. The fact that these were reportedly generated by an AI model significantly amplifies the risk.

**Overall Assessment: CRITICAL** - The library should not be used in any security-sensitive application until the underlying cryptographic primitives are replaced with industry-standard, professionally vetted implementations.

---

## Findings

### 1. [CRITICAL] Homegrown & AI-Generated Cryptographic Primitives

- **Vulnerability:** The library uses custom-written implementations of `SHA-256` and `AES-256` instead of relying on a standard, heavily scrutinized cryptographic library (e.g., OpenSSL, BoringSSL, libsodium).
- **File(s):** `src/aes256.c`, `src/sha256.c`
- **Description:** The file headers indicate these modules were "[LLM-ARCH] Generated with human review." This is an exceptionally high-risk approach for security code.
    1.  **AES-256 (`aes256.c`):** The header claims the implementation is "constant-time" to prevent timing side-channel attacks. Proving this property is extremely difficult and requires specialized expertise far beyond a simple code review. A subtle mistake in the implementation could re-introduce the very vulnerabilities it claims to prevent. An attacker could potentially use cache-timing or other side channels to extract the AES key.
    2.  **SHA-256 (`sha256.c`):** While simpler than AES, a custom SHA-256 implementation can still suffer from subtle correctness bugs that could compromise the integrity of the generator's state.
- **Risk:** A flaw in the AES or SHA-256 implementation could lead to a complete collapse of the CSPRNG's security guarantees, allowing an attacker to predict its output and compromise any protocol or system that relies on it.
- **Recommendation:** **Immediate Remediation Required.** Replace the entire contents of `aes256.c` and `sha256.c` with calls to a standard, FIPS-validated (or equivalent) cryptographic library. The build system should link against this external library. The custom code, especially the AI-generated portions, must be removed.

### 2. [MEDIUM] Potentially Unsafe Memory Management in Entropy Subsystem

- **Vulnerability:** The manual memory management of the global entropy source list (`g_sources`) is complex.
- **File(s):** `src/entropy.c`
- **Description:** The functions for adding and removing entropy sources involve multiple `malloc` and `free` calls. The logic for tracking and cleaning up these allocations (e.g., `stutter_entropy_shutdown`, `stutter_entropy_remove_source`) is complex and could be prone to errors such as memory leaks or use-after-free conditions, especially in a multi-threaded context. A use-after-free bug could potentially be exploited for denial of service or arbitrary code execution.
- **Risk:** Lower than the cryptographic flaw, as it would require a specific pattern of API calls to trigger. However, a bug here could still lead to severe application instability or a security vulnerability.
- **Recommendation:** Refactor the entropy management code to simplify ownership and lifetime of allocated objects. Thoroughly review and test all code paths involving the `g_sources` array.

---

## Positive Security Practices Observed

It is worth noting that the project follows several security best practices:

- **Compiler Hardening:** The `Makefile` correctly implements `-fstack-protector-strong` and `-D_FORTIFY_SOURCE=2`.
- **Warning Cleanliness:** The use of `-Wall -Wextra -pedantic` ensures a high level of code quality and catches many potential bugs.
- **No Obvious Buffer Overflows:** The codebase commendably avoids famously unsafe C functions like `strcpy`, `strcat`, `gets`, and `sprintf`.
- **Safe Format Strings:** All identified uses of `printf` and `fprintf` employ static format strings, preventing format string vulnerabilities.

These positive aspects, however, do not outweigh the critical risk posed by the homegrown cryptographic implementations.
